<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mapping-framework on 梁波的技术博客</title>
    <link>https://amuguelove.github.io/tags/mapping-framework/</link>
    <description>Recent content in mapping-framework on 梁波的技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 23 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://amuguelove.github.io/tags/mapping-framework/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用JMH对Java Object Mapping框架做性能对比</title>
      <link>https://amuguelove.github.io/post/java-object-mappping-framework-benchmark/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://amuguelove.github.io/post/java-object-mappping-framework-benchmark/</guid>
      <description>&lt;h2 id=&#34;jmh概述&#34;&gt;JMH概述&lt;/h2&gt;
&lt;p&gt;JMH 是一个由 OpenJDK/Oracle 里面那群开发了 Java 编译器的大牛们所开发的 Micro Benchmark Framework 。何谓 Micro Benchmark 呢？简单地说就是在 &lt;strong&gt;method&lt;/strong&gt; 层面上的 benchmark，精度可以精确到微秒级。可以看出 JMH 主要使用在当你已经找出了热点函数，而需要对热点函数进行进一步的优化时，就可以使用 JMH 对优化的效果进行定量的分析。&lt;/p&gt;
&lt;p&gt;比较典型的使用场景还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想定量地知道某个函数需要执行多长时间，以及执行时间和输入 n 的相关性&lt;/li&gt;
&lt;li&gt;一个函数有两种不同实现（例如实现 A 使用了 FixedThreadPool，实现 B 使用了 ForkJoinPool），不知道哪种实现性能更好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管 JMH 是一个相当不错的 Micro Benchmark Framework，但很无奈的是网上能够找到的文档比较少，而官方也没有提供比较详细的文档，对使用造成了一定的障碍。但是有个好消息是官方的 &lt;a href=&#34;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&#34;&gt;Code Sample&lt;/a&gt; 写得非常浅显易懂，推荐在需要详细了解 JMH 的用法时可以通读一遍——本文则会介绍 JMH 最典型的用法和部分常用选项。&lt;/p&gt;
&lt;p&gt;我Fork了一份到github，可以提供大家参考一下，使用gradle构建。&lt;a href=&#34;https://github.com/amuguelove/jmh-gradle-samples&#34;&gt;jmh-gradle-samples&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
